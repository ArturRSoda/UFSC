## Introducao ##

    O presente trabalho tem como objetivo aplicar os conhecimentos aprendidos na disciplina Programacao Concorrente, simulando o funcionamento de um bar com numero limitado de rodadas gratis. Cada cliente e garcom serao representados por threads individuais que deverao comunicar entre si. A thread cliente devera realizar as acoes: `conversaComAmigos`, `fazPedido`, `esperaPedido`, `recebePedido` e `consomePedido`; enquanto que a thread garcom devera realizar as acoes: `recebeMaximoPedidos`, `registraPedidos` e `entregaPedidos`. O programa sera parametrizado com as seguintes variaveis, e seus respectivos significados:
    [Adicionar tabela com (coluna1 = nome da variavel) (coluna2 = significado da variavel)]

## Visao geral da solucao ##
    Um dos mais importantes fatores considerados para a realizacao do trabalho foi impedir o busy waiting, situacao em que um processo ou uma thread repetidamente verifica se uma condicao eh verdadeira, gastando grande quantidade de tempo de processamento e energia.
    Portanto, foi decidido que os garcons vao estar em estado bloqueado ate que um cliente faca um pedido, visto que o tempo que um cliente pode ficar conversando eh arbitrariamente grande.
    Tambem foi percebido que se multiplos garcons atendessem os clientes simultaneamente, o programa poderia entrar em deadlock, situacao a qual nenhum dos processos/threads pode prosseguir pois um espera o outro concluir sua acao. Isso eh evidenciado pelo caso {<clientes> == 5, <garcons> == 5, <clientes/garcom> == 2}, em que poderia acontecer de cada garcom atender um cliente, e consequentemente nenhum garcom alcanca sua capacidade [conforme figura X]. Para impedir este problema, foi decidido de apenas um garcom atender os pedidos por vez. [Adicionar grafico para explicar]
    Dessa forma, a solucao escolhida eh que todos os garcons vao estar bloqueados esperando sua vez de atender, com excecao de um, denominado de garcom atual. Este ficara bloqueado ate receber o pedido de um cliente. Quando sua capacidade maxima for atingida, ele ira delegar o cargo de garcom atual para o proximo garcom, antes de registrar e entregar os pedidos. Assim, enquanto um garcom estiver registrando e entregando, o outro estara recebendo os pedidos.
    A responsabilidade de fechar o bar foi delegada aa thread main, que assegura de finalizar as threads.

## Fechamento do bar ##
    Quando o garcom atual estiver na ultima rodada, ele ira dar `post` no semaforo `bar_fechou`. A thread `main`, que estava em `wait` no semaforo `bar_fechou`, sera escalonada
    A thread main chamara `pthread_cancel`, seguido por `pthread_join` nas threads de todos os garcons, encerrando-as.
    Em seguida, as threads dos clientes sao encerradas. Porem, para impedir que a thread do cliente seja encerrada enquanto ele tiver esperando ou consumindo o pedido, a thread main realiza `wait` no semaforo `tem_cliente_conversando_ou_pedindo`, que indica se algum dos clientes esta conversando ou pedindo, mas ainda nao foi atendido pelo garcom. Se houver cliente conversando ou pedindo, a thread main sera escalonada e encerrara a thread que tenha a variavel `conversando_ou_pedindo` atribuida como verdadeiro, por meio de `pthread_cancel` e `pthread_join`. Isso se repetira ate que todas os clientes sejam encerrados. A variavel eh atribuida como verdadeira e o semaforo eh dado um `post` na thread do cliente logo antes da chamada da funcao `conversaComAmigos`, indicando que ele esta conversando ou pedindo. A variavel eh atribuida como falsa e o semaforo eh dado um `wait` na thread do cliente na funcao fazPedido, logo apos o garcom atender (semaforo `garcom_atendeu`), indicando que o cliente nao esta mais conversando ou pedindo.
    Tambem foi adicionada uma condicao que finaliza a thread do cliente logo antes da funcao `conversaComAmigos`, para impedir que o cliente que recem consumiu seu pedido converse de novo com o bar ja em processo de fechamento.

